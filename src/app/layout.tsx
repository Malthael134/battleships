import "@/styles/globals.css";
import { GeistSans } from "geist/font/sans";
import { type Metadata } from "next";
import { TRPCReactProvider } from "@/trpc/react";
import { getServerAuthSession } from "@/server/auth";
import { preferences as preferencesTable } from "@/server/db/schema";
import { Inter } from "next/font/google";
import { db } from "@/server/db";
import { Session } from "next-auth";
import { eq } from "drizzle-orm";
import ThemeProvider from "@/components/theme-provider";
import Topnav from "@/components/topnav";

export const metadata: Metadata = {
    title: "Create T3 App",
    description: "Generated by create-t3-app",
    icons: [{ rel: "icon", url: "/favicon.ico" }],
};

const inter = Inter({ subsets: ["latin"] });

interface RootLayoutProps {
    children: React.ReactNode
}

export default async function RootLayout({
    children,
}: Readonly<RootLayoutProps>) {
    const session = await getServerAuthSession();
    const userPreferences = await getUserPreferences(session);

    return (
        <html
            lang="en"
            className={`${GeistSans.variable}`}
            /* The theme provider causes a hydration mismatch error, because we don't know the theme during ssr.
             * We can ignore that by setting `suppressHydrationWarning` to `true` as done below.
             */
            suppressHydrationWarning
        >
            <body className={`${inter.className} w-full`}>
                <TRPCReactProvider>
                    <ThemeProvider
                        attribute="class"
                        defaultTheme="system"
                        enableSystem
                        disableTransitionOnChange
                    >
                        <Topnav />
                        {children}
                    </ThemeProvider>
                </TRPCReactProvider>
            </body>
        </html>
    );
}

async function getUserPreferences(
    session: Session | null,
): Promise<Omit<typeof preferencesTable.$inferSelect, "id" | "userId">> {
    const preferences = await db.query.preferences.findFirst({
        where: eq(preferencesTable.userId, session?.user.id ?? ""),
    });

    if (!preferences) {
        if (session) {
            await db.insert(preferencesTable).values({
                userId: session.user.id,
            });
        }

        return {
            colorScheme: "system",
        };
    }

    return {
        ...preferences,
    };
}
